# Logish

![](https://github.com/idrag/logish/workflows/build+tests/badge.svg)

MiniKanren with constraints in Java

## Introduction

_Logish_ is a Java 8+ implementation of
[**miniKanren**](http://minikanren.org/), an embedded domain-specific
language for logic programming. The project aims at emulating the key
benefits of fully-fledged
[**Prolog**](https://en.wikipedia.org/wiki/Prolog)-based constraint
logic programming systems in a Java-only environment at an acceptable
performance, and hence the name.

## Features

  - _Logish_ is small and compact: the core system is in a single Java
    source file `Logish.java`, and the finite domain constraint solver
    resides in another file `Fd.java`.
  
  - The usage is simple: for basic use it suffices to import static
    member `Logish.run`, and all static members of `Logish.Goal`.
  
  - _Logish_ internally uses [Java Vavr library](https://www.vavr.io/)
    for immutable functional data structures in Java.  A query result
    is a `Stream` of objects (no need to specify upfront how many
    solutions to look for).
    
  - Constraint solving over finite (integer) domains with linear
    constraints.
    
  - _Logish_ implements attributed variables, allowing multiple
    constraint solvers at the same time. The same mechanism is used by
    `freeze` and the finite domain solver.
    
  
## Basic use

```java
import static org.cellx.logish.Logish.run;
import static org.cellx.logish.Logish.Goal.*;
import io.vavr.collection.Stream;

public class MinimalLogish {

 public static void main(String[] argv) {
   final Stream<Object> result = run(q -> unify(q, "World"));
   for (final Object o: result) {
     System.out.println("Hello, " + o + "!");
   }
 }
}
```

In this example, method `run()` runs a query over a logical variable
named `q`, and returns a stream of values of `q` generated by a
logical goal to the left of `->`.  Here, the goal is `unify(q,
"World")`, which unifies (tries to establish logical equality between)
its arguments.  The logical reading of `run(q -> unify(q, "World")`
is: \`_There exists q such that q is equal to the string literal
`"World"`._' In terms of a search, it can be formulated as: \`_Find q
that satisfies goal `unify(q, "World")`_.\` The obvious solution is for
the initially unknown variable `q` to become equal to string literal
`"World"`.  This is the only solution for `q`, and the resulting
`Stream` has exactly one member. Therefore, the program prints
`"Hello, World!"`.


## Variables, goals and unification

A logic variable is an instance of class `Logish.Var`.  Like a
mathematical variable, it serves as a placeholder for a value (an
object).  Unlike Java variables, a logic variable is not a location in
memory that stores the value: after its value has become known, it
never changes.  In logic programming, and therefore in _Logish_, the
computation if effectivelly a search for values of the variables that
satisfy the goal.

As an example, a query:

```java
run(q -> element(q, List.of(1, 2, 3)))
```

returns (a stream of) all values of variable `q` for which goal `element(q,
List.of(1, 2, 3))` succeeds.  Note that `List.of(1, 2, 3)` is a Java
expression that creates an immutable list (an instance of
_io.vavr.collection.List_) whose elements are integers 1, 2, and 3.  So, for
which _q_ is this goal satisfied?  There are three solutions: _q_=1, _q_=2,
and _q_=3, and so the resulting stream has three elements, 1, 2, and 3.

As in mathematics, logic variables remember when they refer to the same value:
when we know or assume that _x_=_y_, then as soon as we learn _y_=3, we
automatically have _x_=3 as well.  Therefore, the goal:

```
run(q -> seq(unify(q, x), element(x, List.of(1, 2, 3))))
```

where `seq(G1, G2)` is a composite goal that succeeds exactly when both _G1_
and _G2_ succeed, produces exactly the same solution.



